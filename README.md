Порівняльний Аналіз Алгоритмів Сортування (Timsort, Злиття, Вставки)

Мета Завдання

Провести емпіричне порівняння трьох алгоритмів сортування 
 **Timsort** (вбудований у Python), 
 **Сортування Злиттям (Merge Sort)** 
**Сортування Вставками (Insertion Sort)** 

Мета — підтвердити теоретичні оцінки складності ($O(N^2)$ vs $O(N \log N)$) та довести ефективність гібридного алгоритму Timsort.

---

Реалізація та Інструменти

* **Алгоритми:** `insertion_sort` ($O(N^2)$), `merge_sort` та `merge` ($O(N \log N)$).
* **Бенчмаркінг:** Для вимірювання часу виконання використано модуль `timeit`.
* **Timsort:** Тестування здійснювалося через метод `list.sort()`.

---

Результати Емпіричного Тестування

Тестування проводилося на масивах випадкових цілих чисел різного розміру. Час вказано в секундах (s) і є середнім часом виконання за встановлену кількість прогонів.

| Розмір Масиву (N) | **Timsort (час, с)** | **Merge Sort (час, с)** | **Insertion Sort (час, с)** | Співвідношення часу (Timsort:Insertion) |
| :---: | :---: | :---: | :---: | :---: |
| **1000** | <span style="color: green;">0.00007</span> | 0.00862 | 0.01095 | ~ 1:156 |
| **5000** | <span style="color: green;">0.00043</span> | 0.05724 | 0.24885 | ~ 1:578 |
| **10000** | <span style="color: green;">0.00058</span> | 0.00926 | 1.05339 | ~ 1:1816 |
| **20000** | <span style="color: green;">0.00125</span> | 0.02012 | <span style="color: red;">4.30687</span> | ~ 1:3445 |

---

Висновки Щодо Ефективності

Підтвердження Теоретичної Складності

* **Квадратична складність ($O(N^2)$):** Час виконання **Insertion Sort** при збільшенні розміру масиву з $N$ до $2N$ (наприклад, з 10000 до 20000) зростає приблизно в **4 рази**. Це підтверджує, що алгоритми $O(N^2)$ непридатні для великих обсягів даних.
* **Логарифмічно-лінійна складність ($O(N \log N)$):** Час виконання **Merge Sort** та **Timsort** при подвоєнні $N$ зростає лише трохи більше ніж у 2 рази, що відповідає високій ефективності.

Доведення Переваги Timsort

1 **Швидкість:** Timsort стабільно демонструє **найкращий час виконання**, випереджаючи класичний Merge Sort.

2 **Гібридний Підхід:** Ефективність Timsort досягається завдяки поєднанню:
    * **Insertion Sort** для сортування дуже малих підмасивів (де він швидший, ніж рекурсивний Merge Sort).
    * **Merge Sort** для ефективного злиття цих уже відсортованих частин.

Саме ця оптимізація робить Timsort найкращим вибором для реальних даних, які часто є частково відсортованими.

---

*Була реалізована функція `merge_k_lists`, яка використовує алгоритм злиття для об'єднання K відсортованих списків в один відсортований список.*

```python
# Приклад використання:
# lists = [[1, 4, 5], [1, 3, 4], [2, 6]]
# merged_list = merge_k_lists(lists)
# Output: [1, 1, 2, 3, 4, 4, 5, 6]